
\chapter{Python Text Interface}
\label{ug:chapter:python}
\index{user interfaces!python}
\index{Python!interface}

\VMD\ 1.6 and later contain an embedded, fully-functional Python 
interpreter.  The interpreter acts just like the Python command line: you can 
import your own modules and run them from with the text console of VMD.  In 
addition,
\VMD\ provides a number of modules for loading molecules and controlling 
their display.  

\index{Python!version}
Pre-compiled \VMD\ binaries currently use Python version 2.5. The current \VMD\ 
source code has been tested to compile with Python versions 2.4 to 2.6 on
a few platforms. User contributed \VMD\  rpm or deb packages can be thus be
compiled against any of those versions.
 
\section{Using the Python interpreter within VMD}

When you start \VMD, the \VMD\ text console normally uses the Tcl
command interpreter to process what you type.  In order to use the Python
interpreter, you have to tell \VMD\ to switch to 'Python mode'.  There are
three ways to do this: (1) Type {\tt gopython} in the console window; (2)
pass {\tt -python} as a command line option; or (3) put {\tt gopython} on
the last line of your {\tt .vmdrc} file.  If VMD prints an error message
reporting that the Python interpreter is not available, your version
of VMD was not compiled with Python support; contact the VMD developers
for help.  If all goes well, you should see Python command prompt '$>>>$
' in the console window.  To switch back to the Tcl interpreter, press
Ctrl-D as though you were exiting Python.  Switching back and forth
between Python and Tcl does not destroy any of your work; all variables
and modules will still be defined until you exit VMD.

\index{gopython!command}
Typing 'gopython $<$filename$>$', where $<$filename$>$ is the name of a file 
containing Python code will cause VMD to switch to Python mode, process the
file, then switch back to Tcl.  In this way, you can embed Python functions
inside your Tcl scripts! 

You can also type 'gopython -command "{\it your code here}" to run an 
arbitrary line of python code.

\section{Python modules within VMD}
\index{python!environment variables}
\index{python!libraries}

Once you enter the VMD Python environment, you will find a module
called ``VMD" already loaded.  This module contains all the other
built-in modules for writing VMD Python scripts.  

VMD is not distributed with an entire Python environment.  In order to 
use the set
of libraries that normally come with a Python distribution, you must
tell Python where to find the libraries.  There are two primary means
of doing this.  The {\tt PYTHONHOME} environment variable points to
the location where Python is installed; the version installed at this
point must match VMD's version (2.5).  Thus if you have Python libraries
in /usr/local/lib/python2.5, adding the line {\tt set env(PYTHONHOME)
/usr/local} to your startup script or .vmdrc file will do the trick.

If you have additional modules that you want to use within VMD, use the
{\tt PYTHONPATH} environment variable to tell Python where to find them.
Please note that any of these modules have to be compiled against matching
versions of the Python package and its subpackages that are distributed
with the pre-compiled \VMD\ binaries. If you want to use the {\sl native}
Python and its packages, you will have to compile \VMD\ from source code
or install a user contributed package that matches your OS.
See any Python book and the instructions for compiling VMD from source
code for more information.

\index{python!Tkinter}
\index{python!Numeric}
if the Tkinter module is found in the Python installation, VMD will load
it at Python startup in order to make Tkinter windows work in harmony
with windows created from within Tk.  In addition, if you have Numeric
Python installed in your system, a submodule called vmdnumpy will become
available within the VMD module; see below for details.

\section{Atom selections in Python}
\index{atom!selection!Python}
\label{ug:ui:text:python:atomselect}

\subsection{The built-in atomsel type}
{\bf NEW IN VMD 1.8.6}: 
The AtomSel class has been deprecated, in favor of a new built-in
type called {\tt atomsel}.  The atomsel type functions much the
same way as the old AtomSel class, but also provides methods similar
to the Tcl interface for returning RMS fit matrices and applying
those transformations to coordinates.  

\index{python!atomsel}
The new {\tt atomsel} type is found in a new built-in module, also
called {\tt atomsel}.  Use {\tt help(atomsel)} to get the complete
documentation.


\subsection{The AtomSel class (DEPRECATED)}

VMD provides an atom selection class for use in the Python interpreter.
Instances of this class correspond to a set of atom indices in a 
particular molecule for a particular coordinate set.  Once an atom 
selection is made, you can query the properties of the selected atoms,
such as their names, residue ids, or coordinates.  In a similar fashion,
you can set the values of these properties.  You can also perform logical
operations on atom selections, including finding the intersection or 
union of two atom selections or finding the inverse of the set.  Finally,
you can perform tuple operations on the atom selection object to query
the indices of the atoms in the selection.

\index{atom!selection!macros}
\index{atom!selection!Python!macros}

Atom selection macros can be defined using the {\tt macro} method of the
AtomSel module.  The syntax is just as in the corresponding {\tt atomselect 
macro} and {\tt atomselect delmacro} Tcl commands; see 
section \ref{ug:ui:text:atomselect} for details.

\newcommand{\pymodentry}[2]{
  \item {\tt #1}: #2
}

Below we summarize the methods available from the AtomSel class.
\begin{itemize}

\pymodentry{AtomSel(selection = 'all', molid = 0, frame = 0)}{
	Creates a new atom selection object.  

	$>>>$ sel = AtomSel('name CA', 1) \# Selects the alpha carbons of molecule 1
}
\pymodentry{select(selection)}{
	Change the selected atoms.

	$>>>$ sel.select('resid 5')
}
\pymodentry{list()}{
    Return a copy of the selected atom indices.
}
\pymodentry{frame(value = -1)}{
	Set/get the coordinate frame for the selection.  Nonpositive values
	will return the current value of the frame without changing it.

	$>>>$ sel.frame(5)

	$>>>$ sel.frame()

	5
}
\pymodentry{get(attr1, attr2, \ldots)}{
	Takes any number of string arguments, which should correspond to a
	valid atom property such as "name", "x", or "water".  Returns a list
	of the value of the property for each atom in the selection.  For
	boolean properties such as "water", the returned value will be
	1 if true and 0 if false.

	$>>>$ x, y, z = sel.get('x', 'y', 'z')
}
\pymodentry{set(attr, val)}{
	Set the atom property corresponding to {\it attr} using the values in
	{\it val}.  The number of elements in {\it val} should be either 1 or 
	the number in the atom selection.

	$>>>$ len(sel)

	12

	$>>>$ sel.set('beta',3)

	$>>>$ sel.set('beta',(1,2,3,4,5,6,7,8,9,10,11,12))
}
\pymodentry{write(filename, filetype=None)}{
Write the atoms in the selection to filename.  Filetype is guessed
from the filename, or can be specified with filetype.
}
\pymodentry{sel1 \& sel2}{
	Create a new atom selection using the atoms found in both {\it sel1} 
	and {\it sel2}.
}
\pymodentry{sel1 $|$ sel2}{
	Create a new atom selection using the atoms found in either {\it sel1}
	or {\it sel2}.
}
\pymodentry{-sel}{
	Create a new atom selection using the atoms not found in {\it sel}.
}
\pymodentry{len(sel)}{
	Returns the number of atoms in the selection.
}
\pymodentry{sel[0], sel[0:3]}{
	Index and slice operations return the corresponding atoms in the
	selection.
}
\pymodentry{center(weight=None)}{
Return the center of the selected atoms, possibly weighted by 
{\tt weight}, which must be a sequence.
}
\pymodentry{sasa(srad, samples=-1, points=None, restrict=None)}{
        Returns the solvent-accessible surface area (SASA) of atoms in the
        selection using the assigned radius for each atom, extending
        each radius by {\tt srad} to find the points on a sphere that are
        exposed to solvent.  If a {\it restrict} selection is given,
        only solvent-accessible points near that selection bill be considered.
        The {\tt points} parameter can be used to collect the points which
        are determined to be solvent-accessible; this must be a list 
				variable.
}
\pymodentry{getbonds()}{
Returns a list of the atoms bonded to each atom in the selection.
}
\pymodentry{setbonds(bonds)}{
Set the bonds for the atoms in the selection.  {\tt bonds} must be a list
of the same length as the selection; each element in the list must be
a sequence containing the indices of the atoms to which the atom has a bond.
}
\pymodentry{minmax()}{
Returns the minimum and maximum coordinates of the atoms in the selection
as a tuple of the form {\tt (xmin, ymin, zmin), (xmax, ymax, zmax)}.
}
\pymodentry{rmsd(sel, frame=None, weight=None)}{
\index{RMSD}
\index{Python!RMSD}
Returns the root-mean-square distance of the atoms in {\tt sel} from
the selection.  If {\tt frame} is given, the coordinates from the
corresponding frame will be used (see the example).  If {\tt weight}
is given, the computed RMSD will be weighted using the values in {\tt
weight}.  
}
\pymodentry{align(ref=None, move=None, frame=None, weight=None)}{
\index{RMSD}
\index{Python!RMSD}
\index{RMSD}
\index{Python!RMSD}
Finds the transformation that aligns the atoms in the selection with the 
atoms in {\tt ref}, with optional weights {\tt weight}, and applies this 
transformation to the atoms in {\tt move}.  The following default values
for all arguments are provided:
\begin{itemize}
\item {\tt ref}: Same molecule and atoms as selection, but always using the
\pymodentry{align(ref=None, move=None, frame=None, weight=None)}{
\index{RMSD}
\index{Python!RMSD}

Finds the transformation that aligns the atoms in the selection with the 
atoms in {\tt ref}, with optional weights {\tt weight}, and applies this 
transformation to the atoms in {\tt move}.  The following default values
for all arguments are provided:
\begin{itemize}
\item {\tt ref}: Same molecule and atoms as selection, but always using the
first timestep in the molecule.
\item {\tt move}: All atoms in the selection molecule.
\item {\tt frame}: overrides both the selection's frame and the {\tt move}
frame, but does not affect the {\tt ref} frame.
\item {\tt weight}: Defaults to uniform weights on all atoms in selection.
\end{itemize}
}

first timestep in the molecule.
\item {\tt move}: All atoms in the selection molecule.
\item {\tt frame}: overrides both the selection's frame and the {\tt move}
frame, but does not affect the {\tt ref} frame.
\item {\tt weight}: Defaults to uniform weights on all atoms in selection.
\end{itemize}
}

\pymodentry{contacts(cutoff, sel=None)}{
Returns pairs of of atoms within {\tt cutoff of each other}.  If {\tt sel}
is {\tt None}, atoms in the pairs must be in the selection; otherwise, the
first atom in each pair will be from the selection, and the second will
be from {\tt sel}.
}

\end{itemize}

\subsection{An atom selection example}

In the first example, we load the molecule alanin.pdb, and create an atom
selection consisting of the alpha carbons.  Note that AtomSel is the name
of the class which generates atom selection instances.  We show the string 
representation of the object by entering its name and pressing return; this 
shows the text used in the selection.

Next we demenstrate how atom selections act like tuples: we can get their
length using the built-in len() command,and return a copy of the selected 
atoms in a tuple by using the slice operator [:].  

\index{atom!selection!changing properties}
Finally, we demonstrate the get and set operations.  The get() operation takes
any number of string arguments; for each argument, it returns a Python
list of values corresponding to that string.  The set() operation allows only
one property to be changed at a time.  However, you can pass in either a 
single value, which will be applied to all atoms in the selection, or a 
tuple or list of the same size as the atom selection, in which case values
in the list will be assigned to the corresponding atom in the selection.
We take advantage of this behavior in the following example by first saving
the current value of beta for the selection, then setting the value of beta
to 5 for all selected atoms, and finally resetting the original values using
the results of the get(). 

\index{example scripts!Python!calculation!changing properties of a selection}
\begin{verbatim}
>>> from molecule import *
>>> from AtomSel import AtomSel
>>> load('alanin.pdb')

>>> CA = AtomSel('name CA')
>>> CA                  
name CA
>>> len(CA)
12
>>> CA[:]
(0, 5, 11, 17, 23, 29, 35, 41, 47, 53, 59, 65)
>>> resname, resid = CA.get('resname', 'resid')
>>> resname
['ACE', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'ALA', 'C
BX']
>>> resid
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
>>> x,y,z=CA.get('x','y','z')
>>> x
[-2.1840000152587891, 1.4500000476837158, 1.9809999465942383, 0.54100000858306885, 
2.8090000152587891, 5.9079999923706055, 5.0440001487731934, 4.5659999847412109,
7.9340000152587891, 9.7329998016357422, 8.1689996719360352, 9.2229995727539062]
>>> y
[0.5910000205039978, 0.0, 3.6429998874664307, 4.8410000801086426, 2.5559999942779541, 
3.7860000133514404, 7.4190001487731934, 6.7989997863769531, 5.0819997787475586, 
7.9559998512268066, 10.515999794006348, 8.5710000991821289]
>>> z
[0.9100000262260437, 0.0, -0.9089999794960022, 2.3880000114440918, 4.3920001983642578, 
2.5859999656677246, 3.244999885559082, 6.9559998512268066, 7.2639999389648438, 
5.5669999122619629, 7.8870000839233398, 11.013999938964844]

>>> beta = CA.get('beta')
>>> CA.set('beta',5)
>>> CA.set('beta',beta)
>>> 

\end{verbatim}


\subsection{Changing the selection and the frame}

When molecule in VMD contains multiple coordinate sets (frames), atom 
selections must know which frame they are referring to, especially when
you make distance-based atom selections or request time-varying properties
like the x, y, or z coordinates.  By default, atom selections in Python 
use frame 0, i.e. the first coordinate set.  You can specify the frame 
either when you create the atom selection, or by using the frame() method.
Passing no arguments to frame() returns the current value of the frame.

\index{example scripts!Python!calculation!atom selections}
\begin{verbatim}
>>> load('psf','alanin.psf','dcd','alanin.dcd')

>>> resid5 = AtomSel('resid 5', frame=50)
>>> resid5.frame()
50
>>> resid5.frame(22)
>>> resid5.frame()
22
\end{verbatim}

In a similar way, you can change the selected atoms of an atom selection object
using the select() operation.  Continuing with the previous example:

\begin{verbatim}
>>> resid5
resid 5
>>> resid5.select('resid 7')
>>> resid5
resid 7
>>>
\end{verbatim}

\subsection{Combining atom selections}

Once you've created one or more atom selections, you can combine them to
create new ones.  

\index{example scripts!Python!calculation!combining atom selections}
\begin{verbatim}
>>> CA = AtomSel('name CA')
>>> resid5 = AtomSel('resid 5')
>>> CA
name CA
>>> resid5
resid 5
>>> ANDsel = CA & resid5
>>> ORsel = CA | resid5
>>> NOTsel = -CA
>>> ANDsel
(name CA) and (resid 5)
>>> ORsel
(name CA) or (resid 5)
>>> NOTsel
not (name CA)
>>> 
\end{verbatim}

When the combined atom selections are from different
molecules or have different frame numbers, the molecule and frame from the
first atom selection are used.

\subsection{RMS example}
\index{example scripts!Python!calculation!RMSD}
\index{RMSD}

Example: find the mass-weighted RMS distance from the initial frame.
This assumes a molecule and its timesteps have already been loaded
(see the description of the Molecule class).

\begin{verbatim}
from AtomSel import AtomSel
from Molecule import *

# Get a reference to the first molecule.
m=moleculeList()[0]

# Select all atoms.
sel=AtomSel()

# We are comparing to the first frame.
sel.frame(0)

# Get the mass weights.
mass = sel.get('mass')

Here's another RMSD example that uses the {\tt align} method:

\begin{verbatim}
from AtomSel import AtomSel
from Molecule import Molecule

mol1=Molecule()
mol1.load('proteins/alanin.psf')
mol1.load('proteins/alanin.dcd')
n = mol1.numFrames()

sel=AtomSel('backbone')

# align all frames with the first frame, using the backbone atoms
for i in range(1,n):
  sel.align(frame=i)

# align all frames with frame 10.
for i in range(1,n):
  sel.align(ref=sel.frame(10), frame=i)

# Align residues 1-3 from frame 10 with frame 20, but use all backbone atoms
# to perform the fit.
resid123=AtomSel('resid 1 to 3')
sel.align(ref=sel.frame(20), frame=10, move=resid123)
# GOTCHA ALERT: sel.frame(10).align(ref=sel.frame(20)) does not work!!
# That's because sel.frame(10) overrides frame 20 in this case since they
# are applied to the same AtomSel instance.  Either use the frame argument,
# as illustrated here, or create a new AtomSel instance for the reference.

# Perform a mass-weighted RMSD alignment and compute the mass-weighted 
# RMS distance from the first frame.
w=sel.get('mass')
rms=[]
ref=AtomSel('backbone',frame=0)
for i in range(n):
  rms.append(sel.frame(i).align(ref=ref, weight=w).rmsd(ref, weight=w))

# Initialize result list.
rms=[]

# Go!
for i in range(m.numFrames()):
  rms.append(sel.rmsd(sel, frame=i, weight=mass))
\end{verbatim}

Here's another RMSD example that uses the {\tt align} method:

\begin{verbatim}
from AtomSel import AtomSel
from Molecule import Molecule

mol1=Molecule()
mol1.load('proteins/alanin.psf')
mol1.load('proteins/alanin.dcd')
n = mol1.numFrames()

sel=AtomSel('backbone')

# align all frames with the first frame, using the backbone atoms
for i in range(1,n):
  sel.align(frame=i)

# align all frames with frame 10.
for i in range(1,n):
  sel.align(ref=sel.frame(10), frame=i)

# Align residues 1-3 from frame 10 with frame 20, but use all backbone atoms
# to perform the fit.
resid123=AtomSel('resid 1 to 3')
sel.align(ref=sel.frame(20), frame=10, move=resid123)
# GOTCHA ALERT: sel.frame(10).align(ref=sel.frame(20)) does not work!!
# That's because sel.frame(10) overrides frame 20 in this case since they
# are applied to the same AtomSel instance.  Either use the frame argument,
# as illustrated here, or create a new AtomSel instance for the reference.

# Perform a mass-weighted RMSD alignment and compute the mass-weighted 
# RMS distance from the first frame.
w=sel.get('mass')
rms=[]
ref=AtomSel('backbone',frame=0)
for i in range(n):
  rms.append(sel.frame(i).align(ref=ref, weight=w).rmsd(ref, weight=w))

\end{verbatim}

\section{Python callbacks}
\index{callbacks!Python}

Some of your Python scripts may wish to be informed when various events in VMD 
occur.  The mechanism for expressing this interest is to register a callback
function with a special module supplied by VMD.  When the event of interest
occurs, all registered will functions will be called; VMD will pass the
functions information specific to the event.  The set of callbacks events 
is listed in Table~\ref{table:ug:pythoncallbacks}.

\begin{table}[htb]
\label{table:ug:pythoncallbacks}
\caption{Description of callbacks available to Python scripts running in VMD.}
\begin{tabular}{|l|l|l|} \hline
	\multicolumn{1}{|c}{Name} & 
	\multicolumn{1}{|c|}{When called} &
	\multicolumn{1}{|c|}{Function arguments}
	\\ \hline\hline

display\_update & Screen redraw & none \\
frame           & Molecule changes coordinate frame & (molid, frame) \\
help            & User pushes help button on Main window & (name of topic) \\
initialize\_structure & Molecule created or deleted & (molid, 1 or 0) \\
pick\_atom      & Atom picked in graphics window & (molid, atomid, \\
                &                                & key\_shift\_state (1 if shift pressed, 0 otherwise) ) \\
pick\_value     & Bond, angle, or dihedral label created & (value) \\
timestep        & New IMD coordinate frame received & (molid, frame) \\
trajectory      & Completion of coordinate file read/write & (molid, filename)\\

\hline
\end{tabular}
\end{table}

All callback functions must take two arguments.  The first
argument will be an object given at the time the function is registered;
VMD makes no use of this object, it simply saves it and passes it to the
callback when the callback function is called.  The second argument to the
callback function will be a tuple containing 0 or more elements, depending
on the type of callback.  The type of information for each callback is listed
in the third column of Table~\ref{table:ug:pythoncallbacks}.

Callbacks are registered/deregistered using the add\_callback/del\_callback
methods of the VMD.vmdcallbacks module.  The syntax for these methods is:
\index{example scripts!Python!callbacks}
\begin{verbatim}
def add_callback(name, func, userdata = None):

def del_callback(name, func, userdata = None):
\end{verbatim}
{\tt name} should be one of the callback names in 
Table~\ref{table:ug:pythoncallbacks}.  {\tt func} is the function object.
{\tt userdata} is any object; if no object is supplied, None will be passed
as the first argument to the callback function.  To unregister a callback,
use the same name, func, and userdata as were used when the callback was
registered.  The same function may be registered multiple times with different
userdata objects.

\subsection{Using Tkinter menus in VMD}
\index{Python!Tkinter}
The object-oriented interface to Tk known as Tkinter is included with
the embedded Python interpreter.  You can create Tkinter GUI's in the
usual way, with one caveat: the Tkinter.mainloop() method should never
be called, as it will interfere with VMD's own event loop.  VMD will
take care of updating your GUI windows for you.

\section{Controlling VMD from Python}
Commands for controlling VMD from Python are organized into modules which
roughly correspond to Tcl commands.  Importing all the commands in a module
is not recommended as some of the functions (e.g., listall()) overlap.
All commands are listed below, with the name of the module given by the
section heading.

\subsection{animate}
\index{animate!Python module}
Python operations available from the {\it animate} module, used to
control which coordinate frames are displayed.

\begin{itemize}

\pymodentry{forward()}{}
\pymodentry{reverse()}{
	{\tt forward()} and {\tt reverse()} causes VMD to start animating 
	frames automatically in order of increasing or decreasing frame
	number, respectively.
}

\pymodentry{once()}{}
\pymodentry{rock()}{}
\pymodentry{loop()}{
	{\tt once()}, {\tt rock()}, and {\tt loop()} control how frames are
	cycled when VMD is animating a series of frames.  {\tt once()} causes
	VMD to stop when it reaches the first or last frame.  {\tt rock()}
	causes VMD to reverse direction each time it gets to the beginning
	or end.  {\tt loop()} causes VMD to continue from the beginning when
	reaches the last frame, or from the last frame if it gets to the 
	beginning. 
}

\pymodentry{style()}{
	Returns either {\tt 'Once'}, {\tt 'Rock'}, or {\tt 'Loop'}, 
	corresponding to the animation mode VMD is currently in.
}

\pymodentry{goto(frame)}{
	Set the animation to the given frame, and pause the animation.
}

\pymodentry{prev()}{
	Step to the next-lowest frame, then pause.
}

\pymodentry{next()}{
	Step to the next-highest frame, then pause.
}

\pymodentry{pause()}{
	Stop animating frames.
}

\pymodentry{speed(value)}{
	Get/set the relative rate at which VMD animates frames.  {\tt value}
	should lie between 0 and 1.  If a value less than 0 is given, then
	the speed will not be changed.  The new value of the speed is always
	returned.
}

\pymodentry{skip(value)}{
	Get/set the number of frames to skip when animating.  A value of 1
	means every frame is shown; 2 means every other frame is shown; etc.
	If {\tt value} is 0 or less, no change is made.  The new value of
	the speed is always returned.
}

\pymodentry{is\_active(molid)}{
	Returns whether the molecule with the given id is active; that is;
whether it responds to animation or not.
}

\pymodentry{activate(molid, trueorfalse)}{
	Make the molecule with the given id active or not.  Active molecules
update their coordinate frames during animation; inactive molecules do not.
}

\end{itemize}

\subsection{axes}
\index{axes!Python module}
Python operations available from the {\it axes} module, used to
change where the axes are displayed in the graphics window.

\begin{itemize}

\pymodentry{OFF, ORIGIN, LOWERLEFT, LOWERRIGHT, UPPERLEFT, UPPERRIGHT}{
	String constants defined in the {\it axes} module for setting the
location of the axes.
}

\pymodentry{get\_location()}{
	Returns a string object corresonding the current location of the axes.
}

\pymodentry{set\_location(location)}{
	Set the location of the axes, using one of constants defined in the
module.
}
\end{itemize}
	
\subsection{color}
\index{color!Python module}
Python operations available from the {\it color} module, used to
change the color definitions, color maps, or edit the color scale.
All rgb and color scale values should be in the range 0 to 1.

\begin{itemize}

\pymodentry{categories()}{
	Returns a list of available color categories.
}

\pymodentry{get\_colormap(name)}{
	Returns a dictionary of name/color pairs for the given color category.
}

\pymodentry{set\_colormap(name, dict)}{
	Change the color definitions for the colors in the given color 
category.  The keys in {\tt dict} must come from the keys listed by 
{\tt get\_colormap} for that color category, though not all keys need be
listed.  The values must be legal color names.  
}

\pymodentry{get\_colors()}{
	Returns a dictionary whose keys are all the legal color names and
whose corresponding values are the RGB values of the color, represented as
a 3-tuple. 
}

\pymodentry{set\_colors(dict)}{
	Changes RGB values for colors in \VMD.  Keys must be chosen from the
keys returned by {\tt get\_colors()}.  Values must be 3-tuples of floats.
}

\pymodentry{scale\_method()}{
	Returns the current color scale method.
}
\pymodentry{scale\_methods()}{
	Returns a list of all available color scale methods.
}
\pymodentry{scale\_midpoint()}{
	Returns the current color scale midpoint.
}
\pymodentry{scale\_min()}{
	Returns the current color scale minimum.
}
\pymodentry{scale\_max()}{
	Returns the current color scale maximum.
}
 
\pymodentry{set\_scale(method, midpoint, min, max)}{
	Change the color scale method, midpoint, minimum, or maximum.  All
properties may be set using keyword arguments.
}
 
\end{itemize}

\subsection{display}
\index{display!Python module}

Python operations available from the {\it display} module, used to
control the VMD camera as well as screen updates.

\begin{itemize}

\pymodentry{update()}{
	Force a display update, without checking the VMD FLTK menus
}

\pymodentry{update\_ui()}{
	Update the display as well as any other user interfaces.
}

\pymodentry{update\_on()}{
	Tell VMD to regularly update the display and the FLTK menus
}

\pymodentry{update\_off()}{
	Tell VMD not to regularly update the display.  The display will be 
	updated only when display.update() is called.
}

\pymodentry{stereomodes()}{
	Returns a list of the available stereo modes.
}

\pymodentry{PROJ\_PERSP, PROJ\_ORTHO}{
 	String constants defined in the {\tt display} module for setting
the {\tt projection} keyword in the {\tt set} method.
}

\pymodentry{set(**keywordlist)}{
}
\pymodentry{get(key)}{
  	set() and get() control various display properties.  The following 
keywords accept/return floating-point values: {\tt eyesep, focallength, height,
distance, nearclip, farclip}.  The following keywords accept boolean values for
on or off, respectively: {\tt antialias, depthcue, culling}.  
{\tt stereo} should be one of the values returned by {\tt stereomodes()}.  
{\tt projection} should be one of the PROJ constants defined in this module. 
{\tt size} should be a list of two integers corresponding to the width and
height of the display in pixels.
}
\end{itemize}

 
\subsection{evaltcl}
\index{evaltcl!Python module}

The {\it evaltcl} method provides access to the main \VMD\ Tcl interpreter
from Python. It takes a string with Tcl commands as an argument and evaluates
it. Its main purpose is to provide the Python interpreter with access to 
functionality that is only available from Tcl and for which no equivalent 
implementation yet exists in Python, for example the Tcl based plugins.
Usage Examples:

\begin{verbatim}
from VMD import evaltcl

versionid=evaltcl('vmdinfo version')
evaltcl('play somescript.tcl')
\end{verbatim}


\subsection{graphics}
\index{graphics!Python module}

Python operations available from the {\it graphics} module, used to
create custom 3-D objects from graphics primitives.  The first argument to all
operations is the id of a Graphics molecule.  Graphics molecules are created
using the {\tt load()} command in the {\it molecule} module:
{\tt load('graphics', 'test')} creates a Graphics molecule named 'test'.  For
vertices and normals, a tuple with three float items is required.

\begin{itemize}

\pymodentry{triangle(id, v1, v2, v3)}{
	Draw a triangle with the given vertices.
}

\pymodentry{trinorm(id, v1, v2, v3, n1, n2, n3)}{
	Draw a triangle with the given vertices and vertex normals.
}

\pymodentry{cylinder(id, v1, v2, radius=1.0, resolution=6, filled=0)}{
	Draw a cylinder with endpoints specified by the given points.  Radius,
	resolution, and filled (whether the ends should be capped or not) may
	be optionally specified with keyword arguments.
}

\pymodentry{point(id, v)}{
	Draw a point at the given coordinates.
}

\pymodentry{line(id, v1, v2, style='solid', width=1)}{
	Draw a line between the given vertices.  Optionally, the line style 
	may be specified as either 'solid' or 'dashed', and width may be
	any positive integer.
}

\pymodentry{materials(id, onoff)}{
	Turns materials on/off for subsequent graphics primitives.  Primitives
	lying earlier in the stack are not affected.  {\tt onoff} should be
	either 0 (off) or 1 (on).
}

\pymodentry{material(id, name)}{
	Sets the material for all graphics primitives in this molecule.  
{\tt name} should be one of the material names returned by 
{\tt material.listall()}.
}

\pymodentry{color(id, color)}{
	Set the color for subsequent graphics primitives.  {\tt color} may be
	(1) a tuple containing three floats specifying the RGB value, (2) an
	integer corresponding to a color index, or (3) a string corresponding
	to a color name.
}

\pymodentry{cone(id, v1, v2, radius=1.0, resolution=6)}{
	Draw a cone with base at {\tt v1} and point at {\tt v2}.  radius and
	resolution may optionally be specified with keyword arguments.
}

\pymodentry{sphere(id, center=(0.0, 0.0, 0.0), radius=1.0, resolution=6)}{
	Draw a sphere.  The sphere center, radius, and resolution may 
	optionally be specied with keyword arguments.
}

\pymodentry{text(id, pos, text, size=1.0)}{
	Draw text at the given position (specified by a tuple of three floats,
	using the string {\tt text}.  Size may optionally be specified using
	keyword arguments. 
}

\pymodentry{delete(id, index)}{
	Deletes the graphics primitive with the given index.  Alternatively,
	if the string 'all' is passed as the index, all graphics primitives
	will be deleted.
}

\pymodentry{replace(id, index)}{
	Deletes the graphics primitive with the given index.  The next graphics
	primitive added will go in the newly vacated position.  Subsequent
	graphics primitives will resume at the end of the list.
}

\pymodentry{info(ind, index)}{
	Returns a string describing the graphics primitive with the given 
	index.  If the index is invalid, an IndexError exception is raised.
}

\pymodentry{listall(ind)}{
	Returns the indices of the valid graphics primitives in a list.
}
 
\end{itemize}
\subsection{imd}
\index{imd!Python module}

Python operations available from the {\it imd } module, used to
display and interact with a molecule in a molecular dynamics simulation.

\begin{itemize}

\pymodentry{connect(host, port)}{
	Connect to a simulation running on host {\tt host} and listening for
	incoming connections on port {\tt port}.
}

\pymodentry{pause()}{
	If connected, cause the simulation to pause.  
}

\pymodentry{detach()}{
	If connected, detach from the simulation.  The simulation will continue
	to run, but no more frames will be received until a connection is
	re-established.
}

\pymodentry{kill()}{
	If connected, terminate the simulation.  The connection will also be
	abolished.
}

\pymodentry{transfer(rate)}{
	Set/get how often the remote simulation sends coordinate frames to VMD.
	If {\it rate} is omitted or is negative, no action is taken and the
	current value is returned.  A value of 1 corresponds to every frame
	being sent; a value of 2 corresponds to every other frame, etc.
}

\pymodentry{keep(rate)}{
	Set/get how often received coordinates frames are kept by VMD as part
	of an animation.  
	If {\it rate} is omitted or is negative, no action is taken and the
	current value is returned.  A value of 0 means no frames are saved.  
	A value of 1 corresponds to every frame
	being saved; a value of 2 corresponds to every other frame, etc.
}

\pymodentry{copyunitcell(True/False)}{
  Control how unitcell information is passed to the new frame that
  recieved via IMD. If set to {\tt False} (the default) unit cell
  information would be taken from the IMD connection. Since the IMD
  protocol currently has no provisions for communicating the unit
  cell information, the unit cell dimensions are set to zero. If
  set to {\tt True} the cell information is copied from the previous
  frame. \\
  {\bf WARNING:} when using {\tt imd.copyunitcell(True)} with
  simulations in the NPT ensemble, the resulting unitcell information
  will be incorrect.
}
 
\end{itemize}
\subsection{label}
\index{label!Python module}

Python operations available from the {\it label} module, used to
create, show/hide, and delete labels for atoms, bonds, angles, or dihedrals.

\begin{itemize}

\pymodentry{ATOM, BOND, ANGLE, DIHEDRAL}{
	Label types defined by the label module, for use as the first argument
to the add, listall, show, hide, and delete methods.
}

\pymodentry{add(type, molids, atomids)}{
	Create a label of the given type.  {\tt molids} and {\tt atomids}
must be tuples containing 1, 2, 3, or 4 integers for ATOM, BOND, ANGLE, or
DIHEDRAL labels, respectively.  If the label already exists, no action
is performed.  Returns a dict corresponding to the referenced label that
can be used in the show(), hide(), delete(), and getvalues() methods.
}

\pymodentry{listall(type)}{
	Returns a list of labels of the given type.  The elements of the
list are python dictionary objects, with the following keys: {\tt molid},
{\tt atomid}, {\tt value}, {\tt on}.  The values for {\tt molid} and 
{\tt atomid} are tuples containing the molecule id and atom id for the 
label.  {\tt value} is the numerical value of the geometry label, or zero
for ATOM labels.  {\tt on} is 1 if the label is shown, and 0 if the label is
hidden.
}

\pymodentry{show(type, label)}{
	Turn the given label on.  {\tt label} must be a dictionary containing
{\tt molid} and {\tt atomid} keys whose values are tuples.  If the tuples
match the molecule ids and atom ids of the atoms in an existing label,
the label will be turned on.  Raises ValueError if the label does not
exist.
}

\pymodentry{hide(type, label)}{
	Turn the given label off.  {\tt label} must be a dictionary containing
{\tt molid} and {\tt atomid} keys whose values are tuples.  If the tuples
match the molecule ids and atom ids of the atoms in an existing label,
the label will be turned off.  Raises ValueError if the label does not
exist.
}

\pymodentry{delete(type, label)}{
	Delete the given label.  {\tt label} must be a dictionary containing
{\tt molid} and {\tt atomid} keys whose values are tuples.  If the tuples
match the molecule ids and atom ids of the atoms in an existing label,
the label will be deleted.  Raises ValueError if the label does not
exist.
}

\pymodentry{getvalues(type, label)}{
	Returns a list of values of the given label for each coordinate frame
in the label.  If the atoms in the label belong to different molecules, only
the coordinates of the first molecule will be cycled.  If the labels don't
have values (like atom labels), None is returned.
}

\end{itemize}
\subsection{material}
\index{material!Python module}

Python operations available from the {\it material} module, used to
create and modify material properties of molecular representations.

\begin{itemize}

\pymodentry{listall()}{
	Returns a Python list of the names of all available materials.
}

\pymodentry{settings(name)}{
	Returns a Python dictionary of the material settings for material with
	the given {\tt name}.
}

\pymodentry{add(name=None, copy=None)}{
	Create a new material with the given name.  Optionally, copy the properties
  from material {\tt copy} into the new material.  If no name is given, a new
  one will be provided.
}

\pymodentry{delete(name)}{
  Delete the material with the given name.
}

\pymodentry{rename(oldname, newname)}{
	Rename the material with the given name.  The new name must not yet
	be used.
}

\pymodentry{change(name, ambient, specular, diffuse, shininess, mirror, opacity)}{
	Change one or more of the material settings for the material with the
	given name.  Keyword arguments may be used to specify each property.
}

\end{itemize}
\subsection{molecule}
\index{molecule!Python module}

Python operations available from the {\it molecule} module, used to
load molecules and change their representations.

\begin{itemize}

\pymodentry{num()}{
	Returns the number of loaded molecules.
}
\pymodentry{listall()}{
	Returns the molid's of the all the loaded molecules.
}
\pymodentry{exists(molid)}{
Returns true if the molid corresponds to an existing molecule.
}
\pymodentry{new(name)}{
Creates a new empty molecule with the given name and returns its id.
}
\pymodentry{load(structure, sfname, coor, cfname)}{
	Load a molecule with structure type {\it structure} and filename
	{\it sfname}.  Additionally, a separate coordinate file may be 
	provided, of type {\it coor} and name {\it cfname}.  {\bf New in VMD
        1.8:} All \timesteps from {\it cfname} will be processed before the
        function returns.  If successful, the function will return the
        id of the new molecule.

	$>>>$ load('pdb','alanin.'pdb')

	$>>>$ load('psf','alanin.psf','dcd','alanin.dcd')
}

\pymodentry{cancel(molid)}{
	Cancel loading of coordinates file for the given molecule. 
}

\pymodentry{delete(molid)}{
	Delete the specified molecule.
}

\pymodentry{read(molid, type, filename, beg = 0, end = -1, skip = 1, waitfor = 1, volsets = [1])}{}
\pymodentry{write(molid, type, filename, beg = 0, end = -1, skip = 1, waitfor = 1)}{	
	Read or write a file to/from the specified molecule.  For reading, 
if {\tt molid} is -1, a new molecule will be created.  Optional
arguments {\tt beg}, {\tt end}, and {\tt skip} may be specified with keywords;
the default is to load/save all coordinate frames.   {\bf New in VMD 1.8:} The {\tt waitfor} option will cause VMD to process the specified number of frames
before returning.  If {\tt waitfor} is negative, all frames from the file will
be processed before the function returns.  For reading files containing
volumetric datasets, set the volsets parameter to a list of set id's, 
starting from 0, to specify which datasets to load.
}

\pymodentry{add\_volumetric(molid, name, origin, xaxis, yaxis, zaxis, 
   xsize, ysize, zsize, data)}{
Add a volumetric data set to the given molecule.  {\tt origin}, {\tt xaxis},
{\tt yaxis}, and {\tt zaxis} must be 3-tuples specifying the center and scale
of the data.  {\tt xsize}, {\tt ysize} and {\tt zsize} give the number of 
elements along each dimension.  {\tt data} must be a Python list of the correct
size as indicated by the three sizes.
}

\pymodentry{get\_filenames(molid)}{
Returns a list of filenames that have been loaded into this molecule.  }
\pymodentry{get\_filetypes(molid)}{
Returns a list of filetypes corresponding to {\tt get\_filenames}.  }
\pymodentry{get\_databases(molid)}{
Returns a list of databases corresponding to {\tt get\_filenames}.  }
\pymodentry{get\_accessions(molid)}{
Returns a list of accessiosn corresponding to {\tt get\_filenames}.  }
\pymodentry{get\_remarks(molid)}{
Returns a list of remarks corresponding to {\tt get\_filenames}.  }

\pymodentry{delframe(molid, beg=0, end=-1, skip=1)}{
	Delete frames from the specified molecule.  Optional
arguments {\tt beg}, {\tt end}, and {\tt skip} may be specified with keywords;
the default is to delete all coordinate frames.
}

\pymodentry{dupframe(molid, frame)}{
	Copy the coordinates from the given frame and append them as a new
frame.
}

\pymodentry{numframes(molid)}{
	Return the number of coordinate frames in the specified molecule.
}
\pymodentry{get\_frame(molid)}{
	Return the current coordinate frame for the specified molecule.
}
\pymodentry{set\_frame(molid, frame)}{
	Set the current coordinate frames in the specified molecule.
}
\pymodentry{numatoms(molid)}{
	Returns the number of atoms in the specified molecule.
}

\pymodentry{ssrecalc(molid)}{
	Recalculate the secondary structure for the given molecule, using
the current set of coordinates.
}
\pymodentry{name(molid)}{
Returns the name of the given molecule.
}
\pymodentry{rename(molid,newname)}{
  Rename the given molecule.
}

\pymodentry{get\_top(molid)}{}
\pymodentry{set\_top(molid)}{
	Get/set the molid of the top molecule.
}

\pymodentry{get\_periodic(molid, frame=-1)}{}
\pymodentry{set\_periodic(molid, frame=-1, a, b, c, alpha, beta, gamma)}{
  Get/set periodic image settings for the given molecule and timestep (frame).
{\tt get\_periodic} returns a dictionary whose keys are 
{\tt a, b, c, alpha, beta,
gamma}.  {\tt set\_periodic} sets the corresponding values; negative values
will be ignored.
}

\end{itemize}

\subsection{molrep}
\index{molrep!Python module}

Python operations available from the {\it molrep} module, used to
add and modify representation of molecules.

\begin{itemize}
\pymodentry{num(molid)}{
	Returns the number of representations in the given molecule.
}
\pymodentry{addrep(molid, style=None, color=None, selection=None, material=None)}{
	Add a representation to the specified molecule.  If any of the optional
  keywords are specified as well, the new rep will have the specified 
  properties.  Note that these properties become the default for future
  calls to addrep, so that 
  {\tt addrep(0, style='VDW'); addrep(0, color='Name')} will create two
  reps, each with a style of 'VDW'.

}

\pymodentry{delrep(molid, rep)}{
	Delete the specified rep from the given molecule.  
}

\pymodentry{modrep(molid, rep, style, sel, color, material)}{
	Modify the style, atom selection, color, and/or material for the 
	specified molecule and representation.  Any combination of the last
	four arguments may be specified, using positional or keyword 
	arguments.  Returns success.
	
	$>>>$ modrep(0,0,color='name') \# Color the first rep of molecule 0
		by name.

	$>>>$ modrep(0,2, selection='name CA', material='Transparent')
		\# For the third representation of molecule 0, change
		the atom selection to "name CA" and the material to 
		"Transparent"
}
\pymodentry{get\_style(molid, rep)}{}
\pymodentry{get\_selection(molid, rep)}{}
\pymodentry{get\_color(molid, rep)}{}
\pymodentry{get\_material(molid, rep)}{
	Returns the representation style, selection, color, or material,
respectively, for the given representation of the given molecule.
}

\pymodentry{get\_repname(molid, rep)}{}
\pymodentry{repindex(molid, name)}{
These two commands let you assign names to reps and access them by
that name.  The name returned by {\tt get\_repname} is guaranteed to be
unique for all reps in the molecule, and will stay with the rep it was
assigned to even when the order of the reps changes.  Use {\tt repindex}
to find the repid of the rep with the given name; -1 is returned if no
rep with that name exists.}

\pymodentry{get\_autoupdate(molid, rep)}{}
\pymodentry{set\_autoupdate(molid, rep, onoff)}{
These two commands let you turn on/off automatic updating of the atom
selection for a given rep.  Automatic updating means the atom selection
for the rep will be recalculated every time the coordinate frame of
the molecule changes.
}

\pymodentry{get\_colorupdate(molid, rep)}{}
\pymodentry{set\_colorupdate(molid, rep, onoff)}{
These two commands let you turn on/off automatic updating of the 
color for a given rep.  Automatic updating means the color
for the rep will be recalculated every time the coordinate frame of
the molecule changes; this is useful for coloring by Position or User.
}

\pymodentry{get\_smoothing(molid, rep)}{}
\pymodentry{set\_smoothing(molid, rep, n)}{
\index{animation!smoothing}
\index{trajectory!smoothing}
These two commands let you get/set on-the-fly smoothing of molecular
representations.  Atom coordinates used to draw the given rep will be
smoothed with a moving average window size of $2n-1$.
}

\pymodentry{get\_scaleminmax(molid, rep)}{}
\pymodentry{set\_scaleminmax(molid, rep, min, max)}{}
\pymodentry{reset\_scaleminmax(molid, rep)}{
\index{color!scale!set minmax}
    Get/set the color scale range for this rep.  Normally the color scale
    is automatically scaled to the minimum and maximum of the corresponding
    range of data.  This command overrides the autoscaled values with the
    values you specify.  Omit the {\it min} and {\it max} arguments to get
    the current values.  Use {\tt reset\_scaleminax} to rescale the
    color scale to the maximum range again.
}

\pymodentry{get\_visible(molid, rep)}{}
\pymodentry{set\_visible(molid, rep, onoff)}{
\index{representation!show/hide}
These two commands let you show or hide a selected molecular representation,
and retrieve the visibility status of a given rep.
}

\end{itemize}
\subsection{render}
\index{render!Python module}

Python operations available from the {\it render} module, used to
export the scene to a file that can be read by external rendering programs.  

\begin{itemize}

\pymodentry{listall()}{
	Return a Python list of the names of all supported rendering methods.
	One of these should be the first argument to the {\tt render()} 
	operation below.
}

\pymodentry{render(method, filename)}{
	Using the the given rendering method, export the current scene to
	the file {\tt filename}.  {\tt method} should be one of the values 
	returned by {\tt listall()}.
}

\end{itemize}
\subsection{trans}
\index{trans!Python module}

Python operations available from the {\it trans} module, used to
change the view of the rendered scene.  

\begin{itemize}

\pymodentry{rotate(axis, angle)}{
	Rotate the scene about the specified axis by the given angle.  
{\tt axis} should be 'x', 'y', or 'z'; {\tt angle} is measured in degrees.
}

\pymodentry{translate(x, y, z)}{
	Translate the scene by the given x, y, and z values.
}

\pymodentry{scale(factor)}{
	Scale (zoom) the scene by the given factor.
}

\pymodentry{resetview(molid)}{
	Sets the center, scale, rotation for all molecules so that the 
viewpoint is centered on the molecule with the given id.  
}

\pymodentry{get\_center(molid)}{}
\pymodentry{set\_center(molid, vector)}{
	Get/set the coordinates of the center of the given molecule as a
Python list.
}

\pymodentry{get\_scale(molid)}{}
\pymodentry{set\_scale(molid,scale)}{
	Get/set the scale factor used to display the given molecule.
}

\pymodentry{get\_rotation(molid)}{}
\pymodentry{set\_rotation(molid, matrix)}{
	Get/set the rotation matrix for the given molecule as a 16-element
Python list in row-major order.
}

\pymodentry{get\_trans(molid)}{}
\pymodentry{set\_trans(molid, vector)}{
	Get/set the global translation applied to the given molecule as a 
	Python list.
}

\pymodentry{is\_fixed(molid)}{
	Returns whether the molecule with the given id is fixed; that is,
whether it is affected by translation, rotation, or scaling.  Fixed molecules
may still be animated (see {\tt is\_active} in the {\it animate} section).
}

\pymodentry{fix(molid, trueorfalse)}{
	Make the molecule with the given id fixed or not.
}

\pymodentry{is\_shown(molid)}{
	Returns whether the molecule with the given id is shown or not.
}

\pymodentry{show(molid, trueorfalse)}{
	Make the molecule with the given id shown or not.
}
\end{itemize}

\subsection{vmdnumpy}
\index{python!Numeric}
This optional module is made available from within the toplevel VMD module
if VMD detects a Numeric Python installation in the Python search path.
When present, the following methods are provided:

\begin{itemize}
\pymodentry{timestep(molid, frame)}{
Returns a single-precision Numeric array containing a {\bf direct}
reference to the given set of atom coordinates.  Atom coordinates 
are arranged {\it xyzxyzxyz...} for each atom in the molecule.  No
copy of VMD's internal coordinates is made; therefore, modifications
to this array will directly affect atom coordinates in VMD.  Using the
array after the timestep has been deleted will likely cause VMD to crash.
The advantage is maximum efficiency and the ability to easily modify
atom coordinates without going through the atom selection interface.
}
\pymodentry{atomselect(molid, frame, selection)}{
Returns an array of int's representing flags for on/off atoms in 
the given atom selection.  The syntax for the selection is the same
as for the AtomSel class. An array of this form can be used in conjunction
with the Numeric {\tt take} function to get selected coordinates from 
a timestep.  Creating the array in this way can be 50-100 times faster
than converting from an AtomSel object.
}
\end{itemize}

\section{High-level Python Interface}
VMD provides three modules for accessing and manipulating VMD state
with objects that represent important entities.  These objects can
be thought of as references for the actual object within VMD: you
can create as many references as you want and delete them, but modifying
the reference changes the actual state of VMD.  This is different from
the AtomSel class, where each AtomSel instance is independent of 
the molecules and reps in VMD.  These {\it proxy classes} are written
in pure Python and use the lower level built-in interfaces to communicate
with VMD.

\subsection{Molecule}
The Molecule class is a proxy for molecules loaded into VMD.  Most 
operations raise ValueError if the proxy no longer refers to a valid
molecule (i.e. if the molecule has been deleted).  

Molecule instances provide the following methods:
\begin{itemize}
\pymodentry{\_\_init\_\_(id=None)}{
Creating a new Molecule instance with no arguments will create a new 
empty molecule in VMD.  Passing a valid molecule id will make the 
Molecule instance mirror the state of the corresponding molecule in VMD.  }
\pymodentry{\_\_int\_\_()}{
Casting a Molecule to an int returns the molecule ID.  }
\pymodentry{rename(self, newname)}{ Changes the name of the molecule.
}
\pymodentry{name()}{
Returns the name of the molecule.  }
\pymodentry{delete()}{
Deletes the molecule corresponding to this Molecule instance.  The object can
no longer be used.  }
\pymodentry{load(filename, filetype=None, first=0, last=-1, step=1, waitfor=-1, volsets=[0])}{
Load molecule data from the given file.  The filetype will be guessed from
the filename extension; this can be overrideen by setting the filetype
option.  {\tt first}, {\tt last}, and {\tt step} control which coordinates 
frames to load, if any.  {\tt volsets} indicates which volumetric data sets
to load from the file.  Raises IOError if the file cannot be loaded.
}
\pymodentry{save(filename, filetype=None, first=0, last=-1, step=1, waitfor=-1, sel=None)}{
Save timesteps to the given file.  The filetype will be guessed from
the filename extension; this can be overridden by setting the filetype
option.  first, last, and step control which timesteps to save.  Returns
the number of frames written before the command completes.  Pass an 
AtomSel instance as {\tt sel} to write only a selection of atoms to the file.
Note that this differs from the {\tt AtomSel.write()} method in that 
{\tt Molecule.save()} writes a range of timesteps, while {\tt AtomSel.write()}
writes only the coordinates corresponding to the selection's currently 
selected frame.
}
\pymodentry{files()}{}
\pymodentry{types()}{
Returns a list of filenames and file types, respectively, for the files that
have been loaded into this molecule.
}
\pymodentry{numAtoms()}{Returns the number of atoms in the molecule.}
\pymodentry{numFrames()}{Returns the number of coordinate frames in the 
molecule.}
\pymodentry{setFrame(frame)}{
Set the coordinate frame to the given value.  Must be in the range
[0, numFrames())}
\pymodentry{curFrame()}{Returns the current coordinate frame for the molecule.}
\pymodentry{delFrame(first=0, last=-1, step=1)}{
Deletes the given range of frames.}
\pymodentry{dupFrame(frame = None)}{
Duplicate the given frame, apending it to the end.  if {\tt frame} is
{\tt None} then the current frame is used.}
\pymodentry{numReps()}{
 Returns the number of molecular representations (reps) in the given molecule.
}
\pymodentry{reps()}{
Returns a list of MoleculeRep objects, one for each rep in the molecule.}
\pymodentry{addRep(rep)}{
Add the given MoleculeRep instance to the Molecule.  Modifications to the
rep will affect all Molecules to which the rep has been added.  Raises
ValueError if the rep has already been added to this molecule.
}
\pymodentry{delRep(rep)}{
Removes the given MoleculeRep from the Molecule.  The rep is not affected
and can be added to other molecules, but changes to it will no longer affect
this Molecule.  }
\pymodentry{clearReps()}{ Removes all reps from this molecule.  }
\pymodentry{autoUpdate(rep, onoff = None)}{
If {\tt onoff} is not {\tt None}, sets the auto-update status for this rep
and molecule (note that a rep's auto-update status may be different for 
different molecules).  Returns the reps auto-update status.}
\pymodentry{ssRecalc()}{Recalculate the secondary structure for this molecule.}
\end{itemize}

Examples:
\index{example scripts!Python!calculation!loading molecules}
\begin{verbatim}
>>> from VMD import *
>>> from Molecule import *
>>> bR=Molecule()
>>> bR.load('../proteins/brH.pdb')
     <snip>
<Molecule.Molecule instance at 0x406d878c>
>>> bR.name()
'molecule'
>>> bR.rename('bR')
<Molecule.Molecule instance at 0x406d878c>
>>> bR.name()
'bR'
>>> bR.numAtoms()
3762
>>> bR.dupFrame()
<Molecule.Molecule instance at 0x406d878c>
>>> bR.numFrames()
2
\end{verbatim}

\subsection{MoleculeRep}

The MoleculeRep class, defined in the Molecule module, is designed
to make it easy to keep track of the reps in a molecule and to update
reps in many molecules simultaneously.  The way it works is to create
a MoleculeRep instance, then add it to as many molecules as you want
using the Molecule.addRep() method.  The only operations on MoleculeRep
objects is to change their properties; when this occurs, all molecules
to which the rep has been added will be updated.  Deleting a MoleculeRep
instance has no effect.  A list of MoleculeRep instances for a given
molecule can be gotten from the Molecule.reps() method.

The MoleculeRep class provides the following methods:
\begin{itemize}
\pymodentry{\_\_init\_\_(style=defStyle, color=defColor, selection=defSelection, material=defMaterial)}{
Initialize the Rep object with optional style, color, selection and material
properties.  MoleculeRep objects also have attributes with the same names as
the above keywords; these can be used to query the state of the rep.
Don't set these attributes directly; use the {\tt change*} methods below
instead.
}
\pymodentry{changeStyle(style)}{}
\pymodentry{changeColor(color)}{}
\pymodentry{changeSelection(selection)}{}
\pymodentry{changeMaterial(material)}{
Set the draw style, color, atom selection and material for this rep.  If
the rep is assigned to any molecules, the molecule rep will be updated
accordingly.  {\tt style} must be a valid draw style; see the {\tt *Style}
functions below.
}
\end{itemize}

In the following example, we load a molecule, add a new transparent VDW rep
to the molecule, then change the atom selection for the rep to "name CA":

\index{example scripts!Python!drawing!creating representations}
\begin{verbatim}
>>> from VMD import *
>>> from Molecule import *
>>> bR=Molecule()
>>> bR.load('../proteins/brH.pdb')
      <snip>
>>> reps=bR.reps()
>>> reps[0].style
'Lines'
>>> vdw=MoleculeRep(style='VDW', material='Transparent')
>>> bR.addRep(vdw)     
>>> vdw.changeSelection('name CA')
\end{verbatim}

\subsection{Draw Style Methods}
The syntax for changing the draw style in the MoleculeRep.changeStyle()
method is fairly simple and easy to remember as long as the default values
for each style are used; however, remembering that 
{\tt rep.changeStyle("CPK 0.5 0.5 8")} is the way to set the bond radius,
sphere scale, and sphere resolution for CPK is a little more difficult.
The Molecule class defines a function for each draw style to make it easier
to generate the required strings to pass to the changeStyle methods.
Each function accepts keyword arguments for specifying the draw style
parameters and returns a string suitable for {\tt changeStyle()}.  


\subsection{Saving and Restoring Molecule State}
\index{save!vmd state}
Molecule and MoleculeRep instances can be saved used the {\tt pickle}
module from the Python standard library.  Molecules will be saved with
information about their name, files, and reps.  The files themselves
are not saved with the molecule; they will be reloaded when the molecule
instance is recreated using {\tt pickle.load()}.  MoleculeRep instances
can also be pickled; when restored they will be unassigned to any Molecules.

