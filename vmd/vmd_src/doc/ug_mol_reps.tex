%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RCS INFORMATION:
%
%       $RCSfile: ug_mol_reps.tex,v $
%       $Author: johns $        $Locker:  $                $State: Exp $
%       $Revision: 1.45 $      $Date: 2014/12/29 05:10:35 $
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DESCRIPTION:
%  Overview of some vmd topics
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Molecular Drawing Methods}
\label{ug:topic:drawing}

Each molecule in \VMD\ is drawn as a collection of several 
\index{representation}
{\em representations}, of the molecule.  
A representation is just one particular way of drawing the molecule, 
and consists of several characteristics:
\begin{itemize}
  \item An {\em atom selection}, which determines which of the atoms in the 
molecule will be included in the view.  This selection is entered in the text 
input field at the bottom of the Graphics window.  Atom selections don't apply
when drawing volumetric data such as an electron density map, 
electrostatic potential map, etc.
Section \ref{ug:topic:selections} describes the syntax used to select atoms.

  \item A {\em drawing method} (representation {\em style}), 
which determines what shape to draw the
atoms, bonds, and other components of the molecule.  
Section \ref{ug:topic:drawmethods} 
describes the rendering methods available in \VMD.
\index{representation!style}

  \item A {\em coloring method}, which determines how to color each of the 
atoms and bonds included in the view.  The Graphics window contains controls to 
set the coloring method at the right of the window.
Section \ref{ug:topic:coloring} describes \VMD's coloring methods.
\index{coloring!methods}

  \item A {\em material}, which determines the shininess, opacity, and
other lighting and shading characteristics used when rendering the molecule.

\index{atom!selection}
\index{selection}
\end{itemize}
A molecule can contain any number of different representations, and
complex pictures of the molecule can be generated by creating views
with different selections, coloring schemes, and rendering methods.
For example, the protein backbone can be drawn as a smooth tube in one
view, and important residues in the protein can be drawn as spheres or
licorice bonds in other views.  When a molecule is first loaded, it is
given a `default' view, which will draw all the atoms as lines and
points, coloring each atom by what kind of element it is.

\section{Rendering methods}
\label{ug:topic:drawmethods}

All of the different rendering methods have various parameters which
determine how they are drawn.  For each method, there are controls in
the Graphics window which modify the associated parameters, such as the
line width and sphere resolution (the graphical controls are described
in section \ref{ug:ui:window:graphics:controls}).  Table
\ref{table:ug:drawmethods} lists the available rendering methods, and
the following sections describe these methods and the
parameters which modify their appearance.

\begin{table}[htb]
  \hspace{0.5in}
  \begin{tabular}{|l|l|} \hline
%    \multicolumn{1}{|c}{Rendering Method} &
%        \multicolumn{1}{|c|}{Description} \\ \hline\hline
  Representation styles & Description \\ \hline\hline
  Lines		& simple lines for bonds, points for atoms \\
  Bonds		& lighted cylinders for bonds \\
  DynamicBonds  & dynamically calculated distance-based bonds \\
  HBonds        & display hydrogen bonds \\
  Points	& just points for atoms, no bonds \\
  VDW		& solid van der Waal spheres for atoms, no bonds \\
  CPK		& scaled VDW spheres, with cylinders for bonds \\
  Licorice	& spheres for atoms, cylinders for bonds, same radius \\
  Polyhedra     & polyhedra connecting atoms within a cutoff radius \\
  Trace		& connected cylindrical segments through C${}_\alpha$ atoms \\
  Tube		& smooth cylindrical tube through the C${}_\alpha$ atoms \\
  Ribbons	& flat ribbon through the C${}_\alpha$ atoms \\
  NewRibbons    & smooth ribbon through the C${}_\alpha$ atoms \\
  Cartoon	& cartoon diagram (cylinders and ribbons) based on secondary structure \\
  NewCartoon	& smooth cartoon diagram (smooth ribbons) based on secondary structure \\
  PaperChain    & display ring structures as polygons, colored by ring pucker \\
  Twister       & flat ribbon tracing glycosidic bonds, with twists oriented by sugar residues \\
  QuickSurf     & molecular surface (Gaussian density surface) \\
  MSMS		& molecular surface as determined by the program MSMS \\
  Surf		& molecular surface as determined by SURF \\
  VolumeSlice   & display a texture mapped slice from a volumetric data set \\
  Isosurface    & display an isovalue surface from a volumetric data set \\
  FieldLines    & field lines generated by integrating particles by volume gradient vectors \\
  Orbital       & molecular orbital selected by wavefunction type, spin, excitation, and orbital ID \\
  Beads         & per-residue approximate bounding spheres \\
  Dotted	& dotted van der Waals spheres for atoms, no bonds \\
  Solvent       & dotted representation of the solvent accessible surface \\
  \hline
  \end{tabular}
  \caption{Molecular view representation styles.}
  \label{table:ug:drawmethods}
\index{representation!list of available}
\end{table}


%%
%% Bonds-oriented reps
%%
\subsection{Lines}
\label{ug:topic:drawmethods:lines}
\index{representation!Lines}
The default representation is `Lines', which is also known as
`wireframe'.
It draws a line between each atom and the atoms to which
it is bonded.  Both atoms have to be selected before the bond will be
drawn.  The first half of each bond is colored appropriately for the
first atom, while the color of the final half corresponds to the
second atom.  The only parameter for the lines representation is 
the line {\sf Thickness}.  


\subsection{Bonds}
\label{ug:topic:drawmethods:bonds}
\index{representation!Bonds}
Nearly everything about this option is the same as
\hyperref{`Lines'}{`Lines' [\S~}{]}{ug:topic:drawmethods:lines} except that
instead of drawing a bond as a line between two atoms, a cylinder is drawn
instead.  To be more specific, it draws an $n$-sided prism, where the number
of sides is determined in the \hyperref{{\sf Graphics} window}{{\sf Graphics}
window [\S }{]}{ug:ui:window:graphics} by the {\sf Bond Resolution} control and
the radius is given by the value of {\sf Bond Radius}, in Angstroms.  If the
radius or number of sides gets too small, the bonds are drawn as
lines.\index{bonds!resolution}

In order to fine tune the bond representation, \VMD\ does a small
amount of trickery to the prisms.  That is, imagine two hollow
cylinders coming together so that the center of the face of one cylinder is
in the same position as the center of the face of the other cylinder.
Also suppose these two cylinders come together at 90 degrees.
Although most of these two cylinders will overlap, there will appear
to be a gap at their intersection.

To correct for this problem, VMD extends both cylinders somewhat so
that the far ends touch.  If one looks closely, this produces more of
an overlap, but it is much nicer looking than the gap.  When three or
more bonds join at one atom, VMD chooses the lowest numbered bond and
extends all other bonds to meet with that one.  It then extends that
lowest numbered bond to meet with the second lowest numbered one.


\subsection{DynamicBonds}
\index{representation!DynamicBonds}
The `DynamicBonds' representation will automatically perform a
distanced-based bond search for the active atom selection and active
trajectory frame.  This representation does not perform the endpoint fixup
procedure described above for the regular \hyperref{`Bonds'}{`Bonds'
[\S~}{]}{ug:topic:drawmethods:bonds} representation.  Instead, it is
intended to be used in concert with the \hyperref{`VDW'}{`VDW'
[\S~}{]}{ug:topic:drawmethods:vdw} representation to show bonds that are
being created and destroyed during the course of a trajectory.  A bond is
drawn if the atoms are within {\sf Distance Cutoff} of eachother. 


\subsection{HBonds}
\index{representation!HBonds}
\index{hydrogen bonds}
The `HBonds' representation will draw a dotted line between two atoms
if there is a possible hydrogen bond between them.  A possible
hydrogen bond is defined by the following criteria:
\begin{verbatim}
     Given an atom D with a hydrogen H bonded to it and an atom
     A which is not bonded to D, a hydrogen bond exists between
     A and H iff the distance ||D-A|| < dist and the angle D-H-A < ang,
     where ang and dist are user defined.
\end{verbatim}

Only the selected atoms are searched, so both the donor and acceptor
must be selected for the bond to be drawn.  Also, you'll note that the
above doesn't check the atom type of the donor or acceptor; the only
criterion is if it already has or doesn't have a hydrogen.  

One downfall of the current implementation is that it does an
$n^2$ search of the selected atoms so you probably don't want to
show all the HBonds of a very large structure. Look for performance
improvements in future versions of VMD.

If you choose an HBonds representation but fail to see any hydrogen
bonds, it may be because the default {\sf Angle Cutoff} and {\sf Distance
Cutoff} criterion in \VMD\ are too small, so you might want to try
increasing the angle value from 20 to 30 degrees and the distance value from
3 to 4.

The HBonds are drawn as dotted lines of a given width.  The default
{\sf Line Thickness} is 1 but you should probably increase that to 2.  On
most SGIs you can't make it any wider than that, as described in the man
page for linewidth.  The bond is colored by the color associated with the
acceptor.


%%
%% Atom-oriented representations
%%
\subsection{Points}
\index{representation!Points}
`Points' draws each atom as a point, and does not draw any of the
bonds.  This option is useful when rendering very large molecules
containing millions of atoms, particularly for rendering
water or other structures for which geometric detail may not be necessary.
The {\sf Size} of the points can be changed.  When the VMD rendering 
mode is set to GLSL, the Points representation will render 
space filling spheres with a size proportional to the {\sf Size}
parameter, and with performance on par with the non-shaded points
drawn in other rendering modes.

\subsection{VDW}
\label{ug:topic:drawmethods:vdw}
\index{representation!van der Waals}
`VDW' draws the atoms as spheres.  The {\sf Sphere Scale} used is the van der
Waals radius multiplied by a user-selectable scaling factor.  

The {\sf Sphere Resolution} determines how finely to tessellate 
the spheres that are drawn, when using rendering modes and external rendering
tools that can only draw polygonal geometry.  The performance of 
polygonal sphere rendering varies inversely with the number of triangles
produced by tessellation into triangles.  The number of triangles per
sphere varies proportionally with the {\sf Sphere Resolution} parameter 
value squared.  For rendering modes such as GLSL, and for external 
rendering tools that can directly represent spheres and 
other quadric surfaces,  the {\sf Sphere Resolution} parameter has no effect.

Note: Due to variations in atom naming conventions, in rare instances VMD may
improperly assign VDW radii to specific atoms, since VMD determines each atom
type based on the first letter forming its name. For example, VMD would assume
an atom named ``HG'' to be a hydrogen rather than a mercury.  If this happens,
you are always free to redefine the radii, using a syntax much
like that below:
{\tt
\begin{verbatim}
        set sel [atomselect top ``name HG'']
        $sel set radius 1.9
\end{verbatim}
}

\subsection{CPK}
\label{ug:topic:drawmethods:cpk}
\index{representation!CPK}
`CPK' is a combination of both 
\hyperref{`Bonds'}{`Bonds'[\S~}{]}{ug:topic:drawmethods:bonds} and 
\hyperref{`VDW'}{`VDW'[\S~}{]}{ug:topic:drawmethods:vdw} 
in that it draws the atoms as spheres and the bonds as cylinders.  
The resolution and radius can be modified independently.  
The size of the sphere drawn in CPK mode is by default the
scaled-down VDW radius, but this scaling-factor can be changed by adjusting
the {\sf Sphere Scale} parameter.  Since a sphere is drawn for each atom, it
will always be slower than the `VDW' option.
If the radii for a sphere or bond are too small, they will not be drawn.

\subsection{Licorice}
\index{representation!Licorice}
`Licorice' draws the atoms as spheres and the bonds as cylinders.  The
difference between this and 
\hyperref{`CPK'}{`CPK' [\S~}{]}{ug:topic:drawmethods:cpk} is that 
the sphere radius is not controllable; instead, it is made the same 
size as the bond.  This makes for a nice, smooth transition and is one 
of the most often used representations.
It can be rather slow for large molecules.


\subsection{Polyhedra}
\index{representation!Polyhedra}
`Polyhedra' draws a collection of triangles that connect all triplets of
groups of atoms within a user-defined radius.  This is commonly used in
conjunction with specific atom selections for visualization of 
amorphous silicon nanodevice structures and the like.  At present, a
single atom selection is used for all candidate atoms, and only the
radius parameter can be modified.


\subsection{Trace}
\label{ug:topic:drawmethods:trace}
\index{representation!Trace}
This representation applies much of the procedure used to construct the
\hyperref{`Tube'}{`Tube' [\S~}{]}{ug:topic:drawmethods:tube}.  In the end, it
connects the alpha-carbon atoms of successive residues by cylindrical
segments with adjustable width.  In the case of nucleic acids, it is the P
backbone atoms which are connected.  As always, the segment pieces are
colored according to the atom they are associated with.  If the cylinder
radius is made 0.00, then the cylinder segments are replaced with lines.

Note: the Trace option is useful for people doing threading or protein
folding work who only look at the $C_\alpha$ coordinates and residue
names, for then they don't have to build the sidechains necessary to
see their structure.  Also, people working on polymers can fake their
structure by naming everything ``CA.'' in the PDB file and then using
Trace.


\subsection{Tube}
\label{ug:topic:drawmethods:tube}
\index{representation!Tube}
There are two ways to draw a `Tube' representation, one for proteins and
the other for nucleic acids.  The protein tube is a smooth curve through the
selected C${}_\alpha$ positions, and the nucleic acid tube is a smooth curve
through the backbone phosphates.

The protein tube is a spline curve that passes through all the
C${}_\alpha$ atoms in a protein fragment.  Five evenly spaced interpolation
points are found along the curve to break the curve connecting the two
C${}_\alpha$ atoms into six line segments.  If the first C${}_\alpha$ is
selected, the first three segments are colored by the color assigned
to that C${}_\alpha$.  If the second C${}_\alpha$ is selected, the last
three segments are colored by the color of the second C${}_\alpha$.  The
nucleic acid tube is constructed in the same manner except that the
phosphate atoms are used.

The two controls set the spline radius and resolution and have the same
meaning as they did in the \hyperref{`Bond'}{`Bond'
[\S~}{]}{ug:topic:drawmethods:bonds} control.  However, if the bond's {\sf
Radius} becomes 0 or {\sf Resolution} is 2 or less then the spline is drawn
as a simple line.  This make moving and rotation the image much faster.

It is possible to pick with the mouse the C${}_\alpha$ which defines the
tube by clicking near the middle of the six tube segments which are
associated with that atom. 



\subsection{Ribbons}
\label{ug:topic:drawmethods:ribbons}
\index{representation!Ribbons}
The `Ribbons' representation is similar to \hyperref{`Tube'}{`Tube'
[\S~}{]}{ug:topic:drawmethods:tube} in that it follows the same spline curve
for both the protein and nucleic acids.  However, it uses additional
information (the O of the protein backbone or some of the phosphate oxygens
for nucleic acids) to find a normal for drawing the oriented ribbon.  (There
may be some problems with the ribbon definition for nucleic acids as it is
possible for the nucleic acid detection routine to label a residue as a
nucleic acid even though it does not have phosphate oxygens.)

Given the coordinates of each atom and the offset vector for the
ribbon vector, the drawing code finds the spline curves for the top
and bottom of the ribbon.  The two splines are connected by triangles
and both splines are drawn as small tubes.  As with the `Tube'
representation, the six ribbon segments nearest the given atom are
drawn with the color assigned to that atom and the atom can be
selected by clicking near the center of those six elements.

Bond {\sf Radius} and {\sf Resolution} modify the tubes that make up the top
and bottom of the ribbon.  If the radius or resolution get too small, the
tubes are not drawn (this speeds up drawing time by an appreciable amount).
The {\sf Width} controls the width of the ribbon and make it look like
everything from vermicelli to lasagna.  Additionally, the sugars are drawn
filled in with triangles.  This helps highlight the pucker.

Thanks to Ethan Merrit for the ribbon drawing algorithm taken from
Raster3D.


\subsection{NewRibbons}
\label{ug:topic:drawmethods:newribbons}
\index{representation!NewRibbons}
The `NewRibbons' representation is similar to \hyperref{`Tube'}{`Tube'
[\S~}{]}{ug:topic:drawmethods:tube} in that it follows the a spline curve
for both the protein and nucleic acids.  However, it uses additional
information (the O of the protein backbone or some of the phosphate oxygens
for nucleic acids) to find a normal for drawing an oriented ribbon.  (There
may be some problems with the ribbon definition for nucleic acids as it is
possible for the nucleic acid detection routine to label a residue as a
nucleic acid even though it does not have phosphate oxygens.)

The NewRibbons representation uses the alpha Carbons as control points
for a spline which defines the ribbon backbone.  The ribbon is drawn by 
extruding a two-dimensional cross section along the length of the spline
orienting it by referencing the positions of the Oxygens on the protein
backbone.
As with the `Tube' representation, the six ribbon segments nearest the 
given atom are drawn with the color assigned to that atom and the 
atom can be selected by clicking near the center of those six elements.

The {\sf Aspect Ratio} parameter controls the width of the ribbon relative
to the thickness value, as a multiplicative factor.  An aspect ratio of 1.0
yields a Tube-like representation.  The {\sf Resolution} parameter controls
the degree to which the ribbon surface is tesselated with triangles.  Higher
settings yield nicer looking images at the expense of interactive rendering
performance. Points can be interpolated with either a Catmull Rom or
B-Spline by changing the value of {\sf Spline Style}. Note that the B-Spline
does not always pass through the C${}_\alpha$ positions, as it is a smoother
spline.

\subsection{Cartoon}
\label{ug:topic:drawmethods:cartoon}
\index{representation!Cartoon}
The `Cartoon' option produces a simplified representation of a protein
based on its secondary structure.  Helices are drawn as cylinders,
beta sheets as solid ribbons, and all other structures (coils and
turns) as a tube.  If the secondary structure has not yet been
determined, it will be calculated automatically by the program STRIDE.

A helix cylinder is constructed by finding the least squares linear
fit along the coordinates of the helix's C${}_\alpha$ atoms.  If a
given residue's C${}_\alpha$ is selected, the small cylinder (found by
linear interpolation along the line of best fit) is drawn with radius
determined by the radius parameter.  Because this method computes a best
fit, a helix must have at least 3 residues before it is drawn (those
helicies with one or two residues are drawn as a coil).  It is
possible to pick the C${}_\alpha$ for each cylinder segment, but they
are at the location of the C${}_\alpha$, which is not near the axis
cylinder.  Interesting results occur when the whole protein is defined
to be a helix and drawn as a cartoon.

The solid beta ribbon is constructed by building a spline along the
center points between each beta sheet residue.  Again, the spline is
linearly interpolated to find the start and end points for each
residue.  Those are extended to construct the corners for a ribbon
with rectangular cross section (the amount of extension is determined
with the {\sf thickness} parameter).  A ribbon segment is used if the
corresponding C${}_\alpha$ atom is selected.  Note that since this method
assumes the protein is in a beta conformation, it draws a much
smoother ribbon than the standard \hyperref{`Ribbons'}{`Ribbons'
[\S~}{]}{ug:topic:drawmethods:ribbons} option, which draw the ribbon with an
oscillation along the sheet.

The other conformations are drawn as a tube.  Since the endpoints of
the helix cylinder and cartoon sheet are not at the C${}_\alpha$
coordinate, the tube method was slightly changed to make the tube go
to the new locations.  This does not always work, resulting in a tube
which does not quite connect to a cylinder.


\subsection{NewCartoon}
\label{ug:topic:drawmethods:newcartoon}
\index{representation!NewCartoon}
The `NewCartoon' representation is a variation of the original `Cartoon'
combined with the `NewRibbons' representation look and features.  The main
difference between the original `Cartoon' representation and `NewCartoon'
is that helices are left in a ribbon representation which follows 
curved structures much more accurately than the straight cylinders used in
the original `Cartoon' did.

The {\sf Aspect Ratio} parameter controls the width of the ribbon relative
to the thickness value, as a multiplicative factor.  An aspect ratio of 1.0
yields a Tube-like representation.  The {\sf Resolution} parameter controls
the degree to which the ribbon surface is tesselated with triangles.  Higher
settings yield nicer looking images at the expense of interactive rendering
performance. Points can be interpolated with either a Catmull Rom or
B-Spline by changing the value of {\sf Spline Style}. Note that the B-Spline
does not always pass through the C${}_\alpha$ positions, as it is a smoother
spline.


\subsection{PaperChain}
\label{ug:topic:drawmethods:paperchain}
\index{representation!PaperChain}
The `PaperChain' representation finds all rings up to a user-defined
maximum size by walking the molecular topology, then proceeds to render
each ring by fitting a polyhedron to the involved atoms and the ring centroid.
The rings are drawn as bipyramids with a user-controlled height.  The
rings are colored by pucker, using the Cremer-Pople pucker amplitude,
which is defined for all rings of three atoms or greater.

\subsection{Twister}
\label{ug:topic:drawmethods:twister}
\index{representation!Twister}
The `Twister' representation traces glycosidic bonds with a flat
ribbon that twists according to the relative orientation of 
successive sugar residues.  The concept is similar to the familiar
ribbon representations VMD uses for proteins.  The paths connecting
oriented rings are connected by thin ribbons with user-adjustable
width and thickness, and with adjustable geometric resolution, and
the representation handles branched structures.

\subsection{QuickSurf}
\label{ug:topic:drawmethods:quicksurf}
\index{representation!QuickSurf}
\index{molecular surface}
The `QuickSurf' representation computes an isosurface extracted from a 
volumetric Gaussian density map computed from atoms or particles in the
neighborhood of each 
lattice point~\cite{KRON2012,ROBE2012-ZLS,STON2013,STON2013A,CAI2014,STON2014,SENE2014A}.
The density map generation algorithm accumulates Gaussian densities on a
uniformly-spaced 3-D lattice defined within a bounding box
large enough to contain all of the atoms or particles that are selected
as part of the rendered surface; sufficient padding at the edges
of the volume ensures that the extracted surface is not clipped off.
The density map generation algorithm satisfies
\begin{equation}
\rho(\vec{r};\,\vec{r}_1,\vec{r}_2,\dots,\vec{r}_N)
= \sum_{i=1}^{N} e^\frac{-|\vec{r}-\vec{r}_{i}|^2}{2 \alpha^2},
\label{eq:gaussdensity}
\end{equation}
where the density $\rho$ is evaluated at a position $\vec{r}$ by summing
over all $N$ atoms. Each atom $i$ is located at position $\vec{r}_i$ and
has an associated weighting factor $\alpha$ which is determined by
multiplying its radius with user-defined weighting and scaling factors
that customize the visualization to produce a surface with an
appropriate user-defined level of detail.

The QuickSurf representation includes several controls which modify 
the parameters of Eq.~\ref{eq:gaussdensity} to produce a surface that
meets the required spatial fidelity and interactive rendering performance.

\begin{itemize}
\item Resolution -- An overall spatial resolution approximation slider, which
      automatically sets the values of the detailed parameters below
\item Radius Scale -- A radius scaling factor applied to all atoms prior to 
      computing their density map contributions
\item Density Isovalue -- The density isovalue to use when extracting the
      generated isosurface
\item Grid Spacing -- The density map uniform lattice spacing parameter.
\item Surface Quality -- The maximum cutoff distance to use when gathering
      Gaussian density contributions from atoms or particles in the 
      neighborhood of each lattice point
\end{itemize}

Several factors influence the interactive calculation and display
performance of the QuickSurf representation.  The CPU version of the
QuickSurf algorithm is multithreaded, but due to the potential for 
significant memory usage associated with CPU core, the number of CPU 
cores used by the algorithm may be clamped to a maximum of eight,
and for density map volumes approaching 1\,GB in size, or larger,
the algorithm may reduce the number of CPU cores used to four or less
to prevent out-of-memory conditions from occuring at runtime.

On machines equipped with appropriate GPU hardware, the QuickSurf 
representation will use a GPU-accelerated implementation that runs
one to two orders of magnitude faster than the CPU version.  The speed
of the GPU algorithm is somewhat dependent on the memory capacity 
of the target GPUs, since density maps larger than the capacity of the
GPU must be computed in multiple passes.

\subsection{Surf}
\label{ug:topic:drawmethods:surf}
\index{representation!Surf}
\index{molecular surface}
This option uses the molecular surface solver written by Amitabh
Varshney when he was at the University of North Carolina.  When this
option is used, the radii and coordinates are written to a temporary
file and the `surf' executable is run with the {\sf Probe Radius} as a
parameter.  When finished, the output is written to another temporary
file which is then read by \VMD\ and colored and displayed.  The value
of the probe radius is controlled by the sphere radius, and this
is identical to the probe size in \AA.

\begin{itemize}
\item Probe Radius -- Probe radius used to construct the molecular surface
\item Representation Method -- The surface can optionally be drawn using
lines rather than solid triangles
\end{itemize}

This surface is rather slow in both generation and display for systems
over several hundred atoms.  The SURF calculation is quite exact and
will show complete detail even when it isn't needed.  The use of disk
space as an interprocess communications medium takes up about half of
the run time.

There is an \hyperref{environment variable}{environment variable
[\S~}{]}{ug:exec_env:variables}  which can affect the Surf display option:
\index{environment variables!SURF\_BIN}
\begin{itemize}
  \item{\tt SURF\_BIN} -- location of the SURF binary (defaults to
                       {\tt SURF\_\$ARCH} as defined in the vmd startup script)
\end{itemize}

A helpful trick when constructing surfaces is to use the {\sf Apply
Changes Automatically} toggle button on the graphics window wisely.
That is, since surfaces often take a long time to build, changing
viewing parameters such as the probe radius can cause long delays.  By
default, each time you hit the probe radius button, VMD rebuilds the
surface.  If you want to reduce or enlarge the probe radius by several
increments, then you would end up rebuilding the surface multiple
times.  By toggling the afore-mentioned button, you can force VMD to
update on your command only.  This trick is sometimes helpful with
other representations as well.

For a much faster surface rendering method, see the descriptions of
\hyperref{`MSMS'}{`MSMS' [\S~}{]}{ug:topic:drawmethods:msms}.
\hyperref{`QuickSurf'}{`QuickSurf' [\S~}{]}{ug:topic:drawmethods:quicksurf}.


\subsection{MSMS}
\label{ug:topic:drawmethods:msms}
\index{representation!MSMS}
\index{molecular surface}
Another molecular surface renderer is `MSMS', a program written by
Michael Sanner of Olsen's lab at Scripps.  This program is much faster
than Surf, and can be a better choice depending on how it is used.
See the web page \htmladdnormallink{{\tt
http://www.scripps.edu/pub/olson-web/people/sanner/html/msms\_home.html}}
{http://www.scripps.edu/pub/olson-web/people/sanner/html/msms\_home.html}
for more details.  Available options include
\begin{itemize}
\item Which Atoms -- should the surface be of the selection (0) or of the 
contribution of this selection to the surface of all the atoms? (1)
\item Sample Density -- triangle density on the surface (typical values are 1.0
for molecules with more than one thousand atoms and 3.0 for smaller molecules)
\item Probe Radius -- Probe radius used to construct the molecular surface
\item Representation Method -- The surface can optionally be drawn using
lines rather than solid triangles
\end{itemize}

There is an \hyperref{environment variable}{environment variable
[\S~}{]}{ug:exec_env:variables} which can affect the MSMS display option:
\index{environment variables!MSMSSERVER}
\begin{itemize}
  \item{\tt MSMSSERVER} -- location of the MSMS binary (defaults to
                        {\tt msms} which is assumed to be in the user's path)
                        On Windows machines, sets this as a systemwide 
                        environment variable in the environment variables
                        window found in the system properties control panel.
\end{itemize}



\subsection{VolumeSlice}
\label{ug:topic:drawmethods:volumeslice}
\index{representation!VolumeSlice}
\index{volumetric data}
The `VolumeSlice' representation draws a texture mapped two-dimensional
slice from a volumetric data set already loaded into \VMD\ using the
\hyperref{{\tt mol volume}}{{\tt mol volume} [\S~}{]}{ug:ui:text:mol} text
command, or by other means.  The colors span the scalar value range of the
data set, with red indicating low values and blue indicating high values in
the data.  The slice is drawn as a plane perpendicular to the X, Y, or Z
axis, and can be positioned anywhere within the coordinate system of the
volumetric data set.  This feature is currently only available on machines
that have full support for hardware 3-D texture mapping.  On machines
lacking 3-D texturing, nothing will be displayed.  Future versions of \VMD\
will greatly enhance the user interfaces and capabilities of this feature.

The following  selectors control the VolumeSlice representation: 
\begin{itemize}

\item Data Set -- This controls which volume data set is referenced in the
representation, since multiple volumetric data sets can be loaded for a
single molecule.

\item Slice Offset -- The slice setting indicates the position of the volume
slice along the chosen axis, in the coordinate system of the volumetric
data, range 0 to 1.

\item Slice Axis -- The orthogonal axis along which the slice plane moves,
can be X, Y, or Z.

\item Render Quality -- The quality can be set to either {\sf Low}, or 
{\sf Medium}.  The {\sf Low} setting causes the slice texture map 
to be rendered using the color nearest the sample point.  
A quality level of {\sf Medium} indicates that the
slice texture map will be rendered using bilinear interpolation.

\end{itemize}


\subsection{Isosurface}
\label{ug:topic:drawmethods:isosurface}
\index{representation!Isosurface}
\index{volumetric data}
The `Isosurface' representation computes and draws a surface within
a volumetric data field, on a 3-D surface corresponding to points
with a single scalar value.  

There are several settings which control how the isosurface is displayed.
\begin{itemize}

\item Data Set -- This control selects which volume dataset is used for the
isosurface calculation, since a given molecule can contain multiple
volumetric data sets.

\item Isovalue -- The Isovalue control selects the value for which the
isosurface will be computed. In the GUI, when dragging the isovalue slider,
the drawn isosurfaces are temporarily calculated at a lower resolution to 
improve interactivity; to prevent this behavior, you can use the middle or 
right button (or the control/shift/alt modifier keys) while dragging the slider.

\item Draw -- This can be set to {\sf Points}, {\sf Shaded Points},
{\sf Wireframe}, or {\sf Solid Surface}.  The default drawing mode is
{\sf Points}.  When viewing very dense isosurfaces of huge volumetric
maps, the {\sf Shaded Points} drawing method can be an excellent compromise
between the speed of the {\sf Points} method and the quality of the
{\sf Solid Surface} method.

\item Boundary -- Setting the boundary to {\sf Box} causes the volume data
bounding box and coordinate axes to be drawn rather than the isosurface for
the data.  This is often useful when first working with volumetric data, and
checking that the coordinate systems of the volume data and the molecule
match.

\item Step -- This setting can be used to greatly reduce 
the resolution of the generated isosurface, by skipping voxels.

\item Size -- This sets the thickness of the point and 
              line based isosurface representations.

\end{itemize}
This and other volumetric display features will be greatly expanded in
forthcoming releases of \VMD.


\subsection{FieldLines}
\label{ug:topic:drawmethods:fieldlines}
\index{representation!FieldLines}
The `FieldLines' representation computes lines that trace the result
of integrating the motions of massless particles advected by the 
volume gradient vectors associated with each location in a volumetric
dataset.  \VMD\ computes the volume gradient map when a volumetric dataset
is initially loaded, and the particle advection routines use a simple
trilinear interpolation of the volume gradients are along with a fast
(but simple) application of Euler's method to advect the particles at 
each integration step.  The user-adjustable gradient magnitude control
affects which points within the volumetric dataset are considered 
candidates for field line seeds.  The resulting set of seed points
are the initial points from which particles begin advection/integration.
The min and max length controls affect the minimum and maximum length of
the resulting field lines that will be selected for display.  Field lines
shorter than the minimum or longer than the maximum are not displayed.
Similarly, field lines that collide with a critical point in the dataset
early in their integration are discarded.


\subsection{Orbital}
\label{ug:topic:drawmethods:orbital}
\index{representation!Orbital}
The `Orbital' representation draws a molecular orbital isosurface 
corresponding to a user-defined wavefunction amplitude computed on a 
regularly spaced grid, resulting from the selected wavefunction type,
spin, excitation, and orbital index~\cite{STON2009,STON2011A}.  
The size parameter controls the thickness of points and line 
isosurface representations, and the grid spacing parameter controls 
the density of the regular grid upon which the wavefunction amplitude 
is computed.


\subsection{Beads}
\label{ug:topic:drawmethods:beads}
\index{representation!Beads}
A bounding sphere is drawn in place of each residue in the atom selection.
This representation can be used as a crude means of drawing very large
structures in a space filling representation and can be particularly useful
for animating trajectories.

\subsection{Dotted}
\label{ug:topic:drawmethods:dotted}
\index{representation!dotted van der Waals}
Same as \hyperref{`VDW'}{`VDW' [\S~}{]}{ug:topic:drawmethods:vdw} except
that the spheres are drawn dotted instead of solid.  That is, a dot is
placed at each of the vertices of the triangle making up each sphere.  This
can be used, for instance, to imitate a surface representation.


\subsection{Solvent}
\index{representation!solvent representation}
\index{surface!solvent accessible}
\index{surface!molecular}
This method is similar in spirit to the \hyperref{`Dotted'}{`Dotted'
[\S~}{]}{ug:topic:drawmethods:dotted} representation in that
it gives a quick estimate of the molecular surface with a collection
of dots.  However, it goes above and beyond the Dotted option by
giving a more uniform coverage of the surface.  The method that \VMD\
uses to check for overlaps isn't technically correct, but it is fast
and works quite well.  A technical description of the algorithm is as
follows: \\

For each point of the surface distribution (of radius $r$ = atom radius
+ probe radius) of atom $i$, check each of the atoms $j$ to which it is
covalently bound.  If the point is too close to $j$, don't display it.
Also, if the point is too close to any neighbor $k$ of $j$ ($k \neq i$) then
don't draw it.  This is fast since there aren't that many neighbors to
check, but it doesn't omit parts of the surface in contact with atoms
which aren't one or two bonds away.  This can be considered a good
thing since you might get a better idea of the contact surface.

There are three parameters for this option.  One is the {\sf Probe Radius},
which was mentioned in the description.  If the probe radius is too large,
the problem of over-lapping surfaces between non-connected atoms becomes
more apparent.  The second is {\sf Detail Level}, which should probably be
renamed "Density" as it determines the surface density of the distributions.
The higher the detail, the higher the density.  The final option is the {\sf
Representation Method}.  By default the surface is drawn as a collection of
points, but a point is a pixel in size regardless of the scale of the
molecule, so when scaled small the surface density appears high, and when
scaled large, the density appears low.  Method 2 draws little plus signs
instead of points, which does scale better so the density appears more
contant.  Method 3 draw lines between the surface points that are on the
same atom, but makes no attempt to connect the two spheres.

Thanks to Jan Hermans for implementation pointers and thanks again to
Jon Leech for the code to compute the uniform point distributions.  That
code was included as part of the 1.x distribution.

